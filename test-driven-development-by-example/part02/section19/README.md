# 19장 테이블 차리기


## 메모

> ..테스트를 작성하다보면 공통된 패턴을 발견하게 될 것이다.  
> 1) 준비(arrange) - 객체를 생성한다.  
> 2) 행동(act) - 어떤 자극을 준다.  
> 3) 확인(assert) - 결과를 검사한다.  

> ..두 번째와 세 번째 단계인 행동과 확인 단계는 항상 다르지만, 처음 단계인 준비 단계는 여러 테스트에 걸쳐 동일한 경우가 종종 있다.

> ..객체 7 과 9 가 있다고 치자. 이들을 더하면 16 이 나와야 하고, 이들을 빼면 -2 가 나와야 한다. 곱하면 63 이 나올 것이다. 이와 같이 두 번째와 세 번째 단계는 다 다르지만 7 과 9 는 항상 반복된다.

> ..만약 이 패턴이 서로 다른 스케일에서 반복된다면(실제로 그렇다) 테스트를 위해 새로운 객체를 얼마나 자주 생성해야 하는가 하는 문제에 직면하게 된다. 이 때 다음 두가지 제약이 상충한다.  
> 1) 성능 - 여러 테스트에서 같은 객체를 사용한다면, 객체 하나만 생성해서 모든 테스트가 이 객체를 쓰게 할 수 있을 것이다.  
> 2) 격리 - 한 테스트에서의 성공이나 실패가 다른 테스트에 영향을 주지 않기를 원한다.  
  
> ..테스트 사이의 커플링은 확실히 지저분한 결과를 야기한다. 한 테스트가 깨지면, 다음 열 개의 테스트 코드가 올바르더라도 같이 깨지는 식이다.

> ..테스트가 실행되는 순서가 중요한 경우가 있는데, 만약 테스트 B 를 실행하기 전에 테스트 A 를 실행하면 둘 다 제대로 작동하지만, A 를 실행하기 전에 B 를 실행하면 A 가 실패하는 경우도 있다.

> ..당신이 뭔가를 배우고 싶다면, 한 번에 메서드를 하나 이상 수정하지 않으면서 테스트가 통과하게 만들 수 있는 방법을 찾아내려고 노력해라.

> ..테스트 자체도 단순화할 수 있다. 두 경우 모두 WasRun 의 인스턴스를 생성하는데, 이것은 우리가 좀 전에 이야기한 바로 그 상황이다. WasRun 을 SetUp 에서 생성하고 테스트 메서드에서 그걸 사용하게 할 수 있다. 각 테스트 메서드는 깨끗한 새 TestCastTest 인스턴스를 사용하므로 두 개의 테스트가 커플링될 가능성은 없다.

> 일단은 테스트를 작성하는데 있어 간결함이 성능향상보다 더 중요하다고 생각하기로 했다.  
> setUp 을 테스트하고 구현했다.  
> 예제 테스트케이스를 단순화 하기 위해 setUp 을 사용했다.  
> 예제 테스트케이스에 대한 테스트케이스를 단순화하기 위해 setUp 을 사용했다.(자기자신에 대한 뇌수술과 비슷할거라고 말한바 있다)  


## 코드실습

- [Step11 : 새로운 테스트케이스 추가 (WasRun.wasSetUp 검사 추가)](./step11.py)  
- [Step12 : 모델코드 수정 (TestCase.setUp, WasRun.setUp 구현)](./step12.py)  
- [Step13 : 리팩토링 (WasRun.wasRun 초기화 책임을 생성자에서 WasRun.setUp 으로 이동)](./step13.py)  
- [Step14 : 리팩토링 (테스트코드에서의 모델코드 객체 생성 행위 추상화)](./step14.py)  

