# 23장 얼마나 달콤한지


## 메모

> ..놓친 디자인 요소를 찾기 위해 일부러 만드는 중복이 아니라면, 중복은 언제나 나쁘다.

> ..TestSuite 를 구현해야 하는 또 다른 장점은 컴포지트 패턴의 순수한 예제를 제공할 수 있다는 점이다. 우린 지금 테스트 하나와 테스트 집단을 동일하게 다루고 싶은 것이다.

> ..컴포지트의 주요 제약중 하나는 컬렉션이 하나의 개별 아이템인 것처럼 반응해야 한다는 것이다.

> ..호출하는곳에서 TestResult 를 할당하는 전략을 선택하자. 이 패턴은 매개변수수집(collecting parameter) 이라고 부른다.

> ..파이썬은 객체 지원이 추가된 스크립팅 언어다보니 ..전역 참조가 암묵적으로 이루어지므로 self 에 대한 참조를 명시적으로 적어야 한다.

> TestSuite 를 위한 테스트를 작성했다.  
> 테스트를 통과시키지 못한 채 일부분만 구현하였다. 이것은 "규칙" 위반이다. 만약 그때 이걸 직접 발견했다면, 돈주머니에서 테스트케이스 두 개를 공짜로 가져가도 좋다. 테스트를 통과시키고 초록막대 상태에서 리팩토링할 수 있게 할 간단한 가짜구현이 있을것 같긴 한데, 지금은 그게 뭔지 잘 떠오르지 않는다.  
> 아이템과 아이템의 모음(컴포지트)이 동일하게 작동할 수 있도록 run 메서드의 인터페이스를 변경하였고 마침내 테스트를 통과시켰다.  
> 공통된 셋업 코드를 분리했다.  


## 코드실습

- [Step29 : 새로운 테스트케이스 추가 (다중 테스트)](./step29.py)  
- [Step30 : 모델코드 수정 (TestSuite 클래스 정의)](./step30.py)  
- [Step31 : 모델코드 수정 (TestCase.run, TestSuite.run 에서 호스트코드에서 건내받은 TestResult 객체를 사용하도록 변경)](./step31.py)  
- [Step32 : 리팩토링 (TestResult 객체 생성시점을 TestCaseTest.setUp 으로 이동)](./step32.py)  
- [Step33 : 리팩토링 (TestCase.assertEqual, TestCase.assertNotEqual 출력포멧 수정)](./step33.py)  

