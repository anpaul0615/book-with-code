# 17장 Money 회고


## 메모

> ..난 "끝났다" 는 말을 믿지 않는다. TDD를 안벽을 위한 노력의 일환으로 사용할 수도 있겠지만 그건 TDD 의 가장 효과적인 용법이 아니다. 만약 시스템이 크다면, 당신이 늘 건드리는 부분들은 절대적으로 견고해야 한다. 그래야 나날이 수정할 때 안심할 수 있기 때문이다.

> .."다음에 할일은 무엇인가?" 에 관련된 또 다른 질문은 "어떤 테스트들이 추가로 더 필요할까?" 다. 때로는 실패해야 하는 테스트가 성공하는 경우가 있는데, 그럴 땐 그 이유를 찾아내야 한다. 또는 실패해야 하는 테스트가 실제로 실패하기도 하는데, 이때는 이를 이미 알려진 제한사항 또는 앞으로 해야 할 작업 등의 의미로 그 사실을 기록해둘 수도 있다.

> ..마지막으로, **할일 목록이 빌 때가 그때까지 설계한 것을 검토하기에 적절한 시기다.** 말과 개념이 서로 잘 통하는가? 현재의 설계로는 제거하기 힘든 중복이 있는가? (질질 끌며 남아있는 중복은 잠복성 디자인의 증후다)

> ..내가 지금까지 작성한 모든 프로그램을 20번씩 다시 작성해본다면 어떨까? 매번 새로운 통찰을 얻고 놀라움을 경험할 것인가? 더 신중을 기해서 모든 통찰을 처음 세 번 안에 다 얻어낼 방법이 있을까?

> **테스트 코드에는 분기나 반복문이 전혀 없기 때문에 테스트 복잡도는 1이다. 명시적인 흐름 제어 대신 다형성을 주로 사용했기 때문에 실제 코드의 복잡도 역시 낮다.**

> ..한 테스트를 작성하는 것을 단일 단계라고 가정할 때, 그걸 컴파일하고 실행하고 리팩토링 하는 데 얼마나 많은 수정이 필요한가?

> ..리팩토링당 수정횟수는 "두꺼운 꼬리(fat fail)" 혹은 "렙토쿠르토틱 프로파일(leptokurtotic profile)" 을 따르는데, 이는 종형 곡선(bell curve) 과 유사하지만 표준적인 종형 곡선이 예상하는 것보다 좀 더 극단적인 변화가 있는 걸 말한다.
  (※ 분포의 꼬리부분이 두껍게 나타나는 것을 일컬음)

> ..**TDD 의 부산물로 자연히 생기는 테스트들은 시스템의 수명이 다할 때까지 함께 유지돼야 할 만큼 확실히 유용하다.**

> ..만약 테스트 주도 코드의 결함 밀도가 충분히 낮다면, ..의사소통의 증폭기에 좀더 가까운 무언가로 바뀌게 될 것이다. 여기에서 의사소통이란, 시스템이 무엇을 해야하는지에 대해 일반적으로 어떤 느낌을 갖고있는 사람들(A)과 시스템이 실제로 그 일을 하도록 만들 사람들(B) 간의 의사소통이다.

> ..명령문 커버리지(statement coverage) 는 테스트의 질에 대한 충분한 평가 기준이 될 수 없음이 확실하지만, 테스트의 시작점이다. TDD 는 100% 의 명령문 커버리지를 종교적으로 따른다.

> ..결함 삽입(defect insertion) 은 테스트의 질을 평가하는 또 다른 방법이다. 원리는 간단하다. 코드의 의미를 바꾼 후에 테스트가 실패하는지 보는 것이다.

> ..테스트 커버리지를 향상시키는 한 가지 방법은 더 많은 테스트를 작성하는 것인데,

> ..테스트 커버리지를 향상시키는 또다른 방법은 **테스트의 수는 그대로 두면서 프로그램의 로직을 단순화하는 것이다.** 리팩토링 단계가 종종 다음과 같은 효과를 가져온다. 조건문이 메시징으로 바뀌거나 아예 사라진다.

> ..모든 입력의 경우를 따져서 테스트 커버리지를 높이는 대신에, 우리는 테스트를 그대로 두고 코드를 줄여서 동일한 테스트가 다양한 경우를 다루게 한다.

> 테스트를 확실하게 돌아가게 만드는 세가지 접근법 : 가짜로 구현하기, 삼각측량법, 명백하게 구현하기  
> 설계를 주도하기 위한 방법으로 테스트 코드와 실제 코드 사이의 중복을 제거하기  
> 길이 미끄러우면 속도를 줄이고 상황이 좋으면 속도를 높이는 식으로 테스트 사이의 간격을 조절할 수 있는 능력  

