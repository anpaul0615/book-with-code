# 28장 초록 막대 패턴
 

## 메모

> **깨진 테스트가 있다면 그걸 고쳐야 한다.** 빨간 막대를 가능한 한 빨리 고쳐야 하는 조건으로 다룬다면 당신은 금세 초록 막대로 옮겨갈 수 있다는 것을 깨닫게 될 것이다. 코드가 테스트를 통과하게 만들기 위해 이 패턴들을 사용하라. (비록 그 결과 코드가 당신이 한 시간도 견뎌낼 수 없는 것이라고 해도)



### 가짜로 구현하기 (진짜로 만들기 전까지만)

> 실패하는 테스트를 만든 후 첫 번째 구현은 어떻게 하는게 좋을까?  
> 상수를 반환하게 하라. 일단 테스트가 통과하면 단계적으로 상수를 변수를 사용하는 수식으로 수정한다.

> ..어떤 사람들은 가짜로 구현하기에 꽤나 화를 내기도 한다. 왜 들어낼 걸 알면서도 그걸 해야 하나? 왜냐하면 뭔가 돌아가는 걸 가진게 그렇지 않은 것보다 좋기 때문이다.

> ..그들은 어떻게 **가짜 구현을 통해 테스트가 잘못 작성되었다는 것을 알 수** 있었을까? 그들이 그 사실을 알아내기 위해 **실제 구현에 시간을 투자하지 않아서** 기뻐했을 거라고 장담한다.

> ..가짜로 구현하기를 강력하게 만드는 두가지 효과가 있다.  
> 1) 심리학적 : 초록 막대 상태에 있는 것은 빨간 막대 상태에 있는 것과 천지 차이다. **막대가 초록색일 때,** 자신이 어디에 서 있는지 안다. **당신은 확신을 갖고 거기서부터 리팩토링해 갈 수 있다.**  
> 2) 범위(scope)조절 : 프로그래머들은 모든 종류의 미래 문제를 상상하는데 탁월하다. **하나의 구체적인 예에서 시작해서 일반화하게 되면, 쓰잘데기 없는 고민으로 때 이르게 혼동하는 일을 예방할 수 있다.** 다음 테스트케이스를 구현할 때, 이전 테스트의 작동이 보장된다는 것을 알기 때문에 그 다음 테스트케이스에도 집중할 수 있다.  



### 삼각측량

> 추상화 과정을 테스트로 주도할 때, 어떻게 최대한 보수적으로 할 수 있겠는가?  
> **오로지 예가 두 개 이상일 때에만 추상화를 하라.**

> ..삼각측량이 매력적인 이유는 그 규칙이 매우 명확하기 때문이다. 가짜로 구현하기를 위한 규칙들은, 추상을 끌어내기 위한 가짜 구현과 테스트케이스 사이의 중복에 대한 우리 감각에 의존하는 것으로, 약간 모호해 보이고 달리 해석될 수 있다.

> ..삼각측량의 법칙들이 비록 단순해 보이기는 하지만 그것은 무한 루프를 만들어 낸다. 두 단언이 있고 plus 를 위한 바른 구현을 추상화했다면, 두 단언 중 하나를 삭제할 수 있는데, 그것이 다른 하나와 완전히 중복되기 때문이다. 하지만 그렇게 하면 우리는 plus 의 구현을 단순히 상수를 반환하는 것으로 단순화할 수 있는데, 그렇게 되면 다시 단언을 하나 추가해야 한다.

> ..나는 어떤 계산을 어떻게 해야 올바르게 추상화할 것인지에 대해 정말 감잡기 어려울 때만 삼각측량을 사용한다. 그 외의 경우, 명백한 구현이나 가짜로 구현하기에 의존한다.



### 명백한 구현

> 단순한 연산들을 어떻게 구현하는가?  
> 그냥 구현해 버려라.

> ..가짜로 구현하기와 삼각측량은 눈곱만큼 작은 발걸음이다. 때때로 어떤 연산을 어떻게 구현해야 할지 확신이 들기도 한다. 그럼 그렇게 하라.

> ..가짜로 구현하기와 삼각측량의 어중간한 성질에 특별한 미덕이 있는 것은 아니다. 뭘 타이핑해야 할지 알고, 그걸 재빨리 할 수 있다면 그냥 해버려라.

> ..하지만 오로지 명백한 구현만 사용하면 자신에게 완벽함을 요구하게 된다. 이것은 사람을 망연자실케 할 수 있다. 만약 당신이 작성하는 것이 테스트를 통과시킬 수 있는 가장 단순한 변경이 아니라면 어떨까? 만약 파트너가 훨씬 단순한 변경을 보여준다면? 당신은 실패다!

> ..**"제대로 동작하는" 을 푸는 동시에 "깨끗한 코드" 를 해결하려는 것은 한번에 하기에는 너무 많은 일일 수 있다**. 그렇게 되면 우선 "제대로 동작하는" 으로 되돌아가서 그걸 해결하고, 그 후에 "깨끗한 코드" 를 느긋하게 해결하도록 하라.



### 하나에서 여럿으로

> 객체 컬랙션을 다루는 연산은 어떻게 구현하나?  
> 일단은 컬렉션없이 구현하고 그 다음에 컬렉션을 사용하게 한다.

> ..예를 들어 숫자배열의 합을 구하는 함수를 작성한다고 가정하자. 일단 하나로 시작할 수 있다.  
> ```
>	public void testSum() {
>		assertEquals(5, sum(5));
>	}
>	private int sum(int value) {
>		return value;
>	}
> ```

> ..다음에는 `sum(new int[] {5,7})` 을 테스트하고 싶다. 우선은 sum 에 배열을 받아들이는 인자를 하나 추가한다.  
> ```
>	public void testSum() {
>		assertEquals(5, sum(5, new int[] {5}));
>	}
>	private int sum(int value, int[] values) {
>		return value;
>	}
> ```

> ..우리는 이 단계를 변화 격리하기의 예로 볼 수 있다. **테스트케이스에 인자를 추가하면 테스트케이스에 영향을 주지 않으면서 자유로이 구현을 변경할 수 있다.**

> ..이제 단일값 대신 컬렉션을 사용할 수 있다.  
> ```
>	public void testSum() {
>		assertEquals(5, sum(5, new int[] {5}));
>	}
>	private int sum(int value, int[] values) {
>		int sum = 0;
>		for (int i = 0; i < values.length; i++) {
>			sum += values[i];
>		}
>		return sum;
>	}
> ```

> ..다음에는 사용하지 않는 단일 인자를 삭제할 수 있다.  
> ```
>	public void testSum() {
>		assertEquals(5, sum(new int[] {5}));
>	}
>	private int sum(int[] values) {
>		int sum = 0;
>		for (int i = 0; i < values.length; i++) {
>			sum += values[i];
>		}
>		return sum;
>	}
> ```

> ..직전 단계 역시 변화 격리하기의 예로, **코드를 고쳐서 테스트케이스를 바꿔도 코드에 영향이 없도록 했다.**

> ..이제 우리는 계획대로 테스트케이스를 개선할 수 있다.
> ```
>	public void testSum() {
>		assertEquals(12, sum(new int[] {5, 7}));
>	}
> ```


