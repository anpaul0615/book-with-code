# 27장 테스팅 패턴
 

## 메모

> 이 패턴들은 더 상세한 테스트 작성법에 대한 것이다.



### 자식 테스트

> 지나치게 큰 테스트케이스를 어떻게 돌아가도록 할 수 있을까?  
> 원래 테스트케이스의 깨지는 부분에 해당하는 작은 테스트케이스를 작성하고 그 작은 테스트케이스가 실행되도록 하라. 그 후에 다시 원래의 큰 테스트케이스를 추가하라.

> ..빨강/초록/리팩토링 리듬은 성공이 지속되는 것이 너무나도 중요해서, 그 리듬을 잃어버릴 것 같은 위기 순간에 부가의 노력으로 리듬을 유지하는 것은 충분히 가치가 있다.

> ..거슬리는 테스트를 삭제하고 다시 시작한다. "음, 이 세가지를 한 번에 동작하게 하려면 할일이 너무 많겠군. A 를 동작하게 만든 후에 B 를, 그 다음에 C 를 동작하게 만들면 전체가 제대로 동작할 것 같군."



### 모의 객체

> 비용이 많이 들거나 복잡한 리소스에 의존하는 객체를 테스트하려면 어떻게 해야 할까?  
> 상수를 반환하게끔 만든 속임수 버전의 리소스를 만들면 된다.

> ..해법은 대부분의 경우에 진짜 데이터베이스를 사용하지 않는 것이다. 대다수의 테스트는, 마치 데이터베이스인 것처럼 행동하지만 실제로는 메모리에만 존재하는 객체를 통해 작성될 수 있다.  
> ```
>	public void testOrderLookup() {
>		Database db = new MockDatabase();
>		db.expectQuery("SELECT order_no FROM Order WHERE cust_no IS 123");
>		db.returnResult(new String[] {"Order 2", "Order 3"});
>		...
>	}
> ```

> ..성능과 견고함 이외의 모의 객체의 또 다른 가치는 가독성에 있다. 당신은 앞서 나온 테스트를 끝에서 끝까지 읽을 수 있다. 만약 사실적인 데이터로 가득 찬 테스트 데이터베이스를 사용한다면, 어떤 쿼리가 결과 14개를 되돌려야 한다고 명세한 테스트를 보더라도 도대체 왜 14개가 올바른 답인지 알기가 쉽지 않다.

> ..만약 모의 객체를 사용하길 원한다면, (비록 그것들이 싱글톤의 가면을 썼더라도) 값비싼 자원을 전역 변수에 손쉽게 저장해 버릴 수는 없다. 만약 그렇게 한다면, 전역 변수를 모의 객체로 설정하고, 테스트를 실행한 후 다시 전역 변수를 복구시켜 놓아야 한다.

> ..모의 객체는 당신이 모든 객체의 가시성에 대해 고민하도록 격려해서, 설계에서 커플링이 감소하도록 한다.

> ..모의 객체를 사용하면 프로젝트에 위험 요소가 하나 추가된다. 모의 객체가 진짜 객체와 동일하게 동작하지 않으면 어떻게 될까? 모의 객체용 테스트 집합이 진짜 객체에서 사용 가능해질 때 그대로 적용해서 이러한 위험을 줄일 수 있다.



### 셀프 션트

> 한 객체가 다른 객체와 올바르게 대화하는지 테스트하려면 어떻게 할까?  
> 테스트 대상이 되는 객체가 원래의 대화 상대가 아니라 테스트케이스와 대화하도록 만들면 된다.

> ..그런데 왜 이벤트리스너를 위해 별도의 객체를 만들어야 하는 걸까? 그냥 테스트케이스 자체를 리스너로 쓰면 될 텐데 말이다. 즉 테스트케이스가 일종의 모의 객체 노릇을 하는 것이다.

> ..셀프 션트 패턴을 이용해 작성한 테스트가 그렇지 않은 테스트보다 읽기에 더 수월하다. 위의 테스트가 좋은 예다. 통보 횟수가 0 이었다가 1 로 됐다. 이 순서를 테스트에서 바로 읽어낼 수 있다.

> ..셀프 션트 패턴은 테스트케이스가 구현할 인터페이스를 얻기 위해 인터페이스 추출을 해야한다. 인터페이스를 추출하는 것이 더 쉬운지, 존재하는 클래스를 블랙 박스로 테스트하는 것이 더 쉬운지는 당신이 결정해야 할 것이다.



### 로그 문자열

> 메시지의 호출 순서가 올바른지를 검사하려면 어떻게 해야할까?  
> 로그 문자열을 가지고 있다가 메시지가 호출될 때마다 그 문자열에 추가하도록 한다.

> ..로그 문자열은 특히 옵저버(Observer)를 구현하고, 이벤트 통보가 원하는 순서대로 발생하는지를 확인하고자 할 때 유용하다. 만약 어떤 이벤트 통보들이 일어나는지를 검사하기는 하지만 그 순서는 상관이 없을 경우엔 문자열 집합을 저장하고 있다가 단언(assertion)에서 집합 비교를 수행하면 된다.

> ..로그 문자열은 셀프 션트와도 잘 작동한다. 해당 테스트케이스는 로그를 추가하고 적절한 값을 반환하는 식으로 셀프 션트한 인터페이스의 메서드를 구현한다.



### 크래시 테스트 더미

> 호출되지 않을 것 같은 에러코드(발생하기 힘든 에러 상황)를 어떻게 테스트할 것인가?  
> 실제 작업을 수행하는 대신 그냥 예외를 발생시키기만 하는 특수한 객체를 만들어서 이를 호출한다.

> ..파일시스템에 여유 공간이 없을 경우 발생할 문제에 대해 테스트하기를 원한다고 생각해보자. 실제로 큰 파일을 많이 만들어서 파일시스템을 꽉 채울수도 있고, 가짜 구현(fake it)을 사용할 수도 있다.  
> ```
>	private class FullFile extends File {
>		public FullFile(String path) {
>			super(path);
>		}
>		public boolean createNewFile() throws IOException {
>			throw new IOException();
>		}
>	}
> ```

> ..객체 전체를 흉내낼 필요가 없다는 점을 제외하면 크래시 테스트 더미는 모의 객체와 유사하다.

> ..자바의 익명 내부 클래스는 우리가 테스트하기 원하는 적절한 메서드만이 오류를 발생시키게끔 하기 위해 유용하게 쓰인다. 테스트케이스 안에서 원하는 메서드 하나만 재정의할 수 있다.  
> ```
>	public void testFileSystemError(){
>		File f = new File("foo") {
>			public boolean createNewFile() throws IOException {
>				throw new IOException();
>			}
>		};
>		try {
>			saveAs(f);
>			fail();
>		} catch (IOException e) {
>		}
>	}
> ```

> ..가짜라는건 별로 점잖아 보이지 않는다. 안그런가? 그냥 시뮬레이션한다고 하자.



### 꺠진 테스트

> 혼자서 프로그래밍할 때 프로그래밍 세션을 어떤 상태로 끝마치는게 좋을까?  
> 마지막 테스트가 깨진 상태로 끝마치는 것이 좋다.

> ..프로그래밍 세션을 끝낼 때 테스트케이스를 작성하고 이것이 실패하는 것을 확실히 확인하는 것이다. 나중에 다시 코딩하기 위해 돌아왔을 때, 어느 작업부터 시작할 것인지 명백히 알 수 있다. 전에 하고 있던 생각에 대한 명확하고 구체적인 책갈피를 가지게 되는 것이다.



### 깨끗한 체크인

> 팀 프로그래밍을 할 때 프로그래밍 세션을 어떤 상태로 끝마치는 게 좋을까?  
> 모든 테스트가 성공한 상태로 끝마치는 것이 좋다.

> ..다른 팀원들과 함께 작업하는 경우라면 상황은 완전히 달라진다. 팀 프로젝트에서 프로그래밍 세션을 시작하는 경우라면 자신이 마지막으로 코딩한 다음부터 지금까지 무슨 일이 있었는지 세밀하게 알 수 없다. 안심이 되고 확신이 있는 상태에서 시작할 필요가 있다. 따라서 코드를 체크인하기 전에 항상 모든 테스트가 돌아가는 상태로 만들어 두어야 한다.

> ..체크인하기 전에 실행하는 테스트슈트는 작업중에 분 단위로 실행하는 테스트슈트보다 더 클 것이다. ..때론 통합 테스트슈트에서 테스트가 실패하는 경우도 있을 것이다. 그럴 떈 어떻게 해야 할까?

> ..가장 단순한 규칙은 그동안 작업한 코드를 날려버리고 다시 하는 것이다. 실패한 테스트는 방금 여러분이 만들어 낸 프로그램을 여러분이 완전히 이해하지 못했음을 말해주는 강력한 증거다.

> ..이 방법보다 아주 약간 방탕해 보이는 접근은, 문제를 수정하고 테스트를 다시 실행해보는 것이다. 통합 자원을 독차지하는 것을 피하기 위해, 아마도 몇 분 후에는 그냥 포기해버리고 다시 시작해야 할 것이다.


