# 32장 TDD 마스터하기


## 메모

> TDD 를 여러분 각자의 습관에 통합시켜 나가는 과정에서 숙고해볼 수 있는 몇 가지 질문을 던지고자 한다.



### 단계가 얼마나 커야 하나?

> ..사실 여기에는 두 가지 질문이 숨어 있다.  
> 1) 각 테스트가 다뤄야 할 범위는 얼마나 넓은가?  
> 2) 리팩토링을 하면서 얼마나 많은 중간 단계를 거쳐야 하는가?  

> ..여러분은 한 줄의 로직을 추가하고 약간의 리팩토링을 할 수 있을 정도 크기의 테스트를 만들 수 있는가 하면, 수백 줄의 로직과 수시간 분량의 리팩토링을 할 만큼의 크기를 갖는 테스트를 만들 수도 있다. 이중 어떤 것이 옳은가?

> ..여러분은 둘 다 할 수 있어야 한다.

> ..리팩토링 초기에는 아주 작은 단계로 작업할 준비가 되어 있어야 한다. 수작업 리팩토링은 에러가 발생하기 쉬운데, 그렇게 해서 더 많은 실수를 하고 그걸 나중에야 잡게 된다면 결국 당신은 리팩토링을 점점 덜 하게 될 것이다. 매우 작은 단계로 수작업 리팩토링을 20번 하고 나면, 몇단계 건너 뛰는 실험을 해보라.

> ..자동화된 리팩토링 툴은 리팩토링을 엄청나게 가속화시킨다. ..훌륭한 툴의 지원이 있다는 걸 알고 있다면 코드가 어떤 구조를 갖추길 원하는지 보기 위해 여러 가지 실험을 시도하면서 리팩토링에 훨씬 적극적이게 될 것이다.



### 테스트할 필요가 없는 것은 무엇인가?

> ..**"두려움이 지루함으로 변할때까지 테스트를 만들어라"**

> ..다음 목록을 시도해보라. 다음 것들을 테스트해야 한다.  
> 1) 조건문  
> 2) 반복문  
> 3) 연산자  
> 4) 다형성  

> ..하지만 당신이 작성하는 것들에 대해서만 테스트해라. **불신할 이유가 없다면 다른 사람이 만든 코드를 테스트하지 마라.**



### 좋은 테스트를 갖췄는지의 여부를 어떻게 알 수 있는가?

> ..테스트란 탄광속에서 ..가스의 존재를 드러내는 카나리아다.

> 다음은 설계문제가 있음을 알려주는 테스트의 속성이다.  
> 1) 긴 셋업 코드
> 2) 셋업 중복
> 3) 실행 시간이 오래 걸리는 테스트
> 4) 깨지기 쉬운 테스트



### TDD 로 프레임워크를 만들려면 어떻게 해야 하나?

> ..코드의 미래에 대해 고려하지 않음으로 인해, 코드가 더 뛰어난 적응성을 가질 수 있게 한다.

> ..테스트 주도 개발은 비록 발생하지 않은 (혹은 아직 발생하지 않은) 변주 종류는 잘 표현하지 못할지라도, 발생하는 변주 종류들을 잘 표현하는 프레임워크를 만들게 해준다.

> ..3년 후에 일반적이지 않은 변화가 발생하면 어떻게 될까? 그 변화를 수용하기 위해 정확히 필요한 지점에서 설계가 급격한 진화를 거치게 된다. 개방-폐쇄 원칙을 잠시 위배하게 되지만, 이에 따른 비용은 크지 않다. 왜냐하면 여러분이 뭔가를 잘못하지 않았다는 확신을 줄 수 있는 수 많은 테스트들이 존재하기 때문이다.

> ..**변화를 매우 빨리 연달아 도입하는 극한적 상황에서 TDD 는 미리 설계하고 개발하는 것처럼 보인다.**



### 피드백이 얼마나 필요한가?

> ..나는 테스트를 얼마나 작성할지 고려할 때, 실패간 평균시간(MTBF, Mean Time Between Failures) 을 생각한다.

> ..엄청나게 큰 정수로 메모리를 가득 채우는 테스트를 해야만 할까? 이 테스트가 내 프로그램의 MTBF 에 어떤 영향을 미칠 것인가? 만약 내가 그렇게 큰 삼각형을 만들 일이 없다면, 이 테스트가 있으나 없으나 내 프로그램의 견고성에 영향을 주지 않을 것이다.

> ..어떤 테스트를 작성할 필요가 있을지 없을지는 당신이 MTBF 를 얼맘나 조심스럽게 측정하는지에 달렸다.

> ..TDD 의 테스트에 대한 관점은 실용적이다. TDD 에서 테스트는 어떤 목적을 위한 하나의 수단이다. 여기서 목적은 우리가 깊이 신뢰할 수 있는 코드가 되겠다. **만약 어떤 구현에 대한 지식 신뢰할 만 하다면 그에 대한 테스트는 작성하지 않을 것이다.**



### 테스트를 지워야 할 때는 언제인가?

> ..테스트가 많으면 좋기야 하지만, 서로 겹치는 두 개의 테스트가 있어도 이들을 남겨두어야 하는가? 대답은 두 가지 기준에 의해 결정된다.  
> 1) 첫째 기준은 자신감이다. 테스트를 삭제할 경우 자신감이 줄어들 것 같으면 절대 테스트를 지우지 말아야 한다.  
> 2) 둘째 기준은 커뮤니케이션이다. 두 개의 테스트가 코드의 동일한 부분을 실행하더라도, 이 둘이 서로 다른 시나리오를 말한다면 그대로 남겨두어야 한다.  

> ..자신감이나 커뮤니케이션 면에서 별 부가적인 이득이 없는 중복된 테스트가 두 개 있다면, 덜 유용한 것을 삭제하라.



### 프로그래밍 언어나 환경이 TDD 에 어떤 영향을 주는가?

> ..**TDD 주기(테스트/컴파일/실행/리팩토링) 를 수행하기가 힘든 언어나 환경에서 작업하게 되면 단계가 커지는 경향이 있다.**  
> ex) 각 테스트가 더 많은 부분을 포함하게 만든다.  
> ex) 중간 단계를 덜 거치고 리팩토링을 한다.  

> ..**TDD 주기를 더 잘 지원하는 언어와 환경에서 작업하게 되면 더 많은 실험을 해보려고 할 것이다.**



### 거대한 시스템을 개발할 때에도 TDD 를 할 수 있는가?

> ..시스템에 있는 기능의 양은 TDD 의 효율에 영향을 미치지 않는 것 같다. 중복을 제거함에 따라 더 작은 객체들이 만들어지게 되고, 이 작은 객체들은 애플리케이션의 크기와 무관하게 독립적으로 테스트 될 수 있다.



### 애플리케이션 수준의 테스트로도 개발을 주도할 수 있는가?

> .**.작은 규모의 테스트로 개발을 주도하는 것의 문제는, 실제로 사용자가 원하지 않는데 그들이 원할 거라 생각하고 구현할 수도 있는 위험을 끌고 간다는 점에 있다.**

> ..아직 만들지 않은 기능에 대한 테스트를 어떻게 작성하고 실행할 것인가? ..아직 어떻게 해석해야 할지 모르는 테스트를 만났을 때 우아하게 에러를 뱉어내는 해석기(interpreter) 를 도입하는 것이다.

> ..또한 애플리케이션 테스트 주도 개발(ATDD, Application Test-Driven Development) 에는 사회적인 문제도 존재한다. 테스트를 작성하는 것은 사용자에게는 기존에 없던 새로운 책임이 되는 것이다. 게다가 이 책임은 "구현하기 전" 이라는 기존에 존재하지 않던 단계에서 수행되어야 한다.

> ..ATDD 의 또 다른 문제는 테스트와 피드백 사이의 길이다. 만약 사용자가 테스트를 만들고 그 테스트가 통과하길 기다리는 동안 열흘이 걸린다면 거의 대부분의 시간을 빨간 막대를 보며 지내게 될 것이다. 내 생각에 난 앞으로도 프로그래머 수준의 TDD 를 원할 것 같다.



### 프로젝트 중반에 TDD 를 도입하려면 어떻게 해야 할까?

> ..가장 큰 문제는 이렇다. **테스트를 염두에 두지 않고 만든 코드는 테스트를 하기가 그리 쉽지 않다는 점이다.** 일부분만을 격리해서 실행하고 결과를 검사할 수 있게끔 인터페이스가 설계되어 있지 않다.

> .."고치면 되잖아" 하고 말할 수도 있을 것이다. 맞다. 하지만 리팩토링 과정에서 에러를 만들 수도 있는데, 아직 테스트가 없기 때문에 에러가 생겼다는 점을 알아낼 수 없을 것이다.

> ..**확실히 하지 말아야 할 일이 있는데, 그것은 코드 전체를 위한 테스트를 한꺼번에 다 만들고, 코드 전체를 한번에 리팩토링 하는 일이다.** 이런 작업은 몇 달이나 걸릴텐데, 그 몇 달 동안 아무도 새로운 기능도 추가로 구현하지 못할 것이다. 수입 없는 지출은 일반적으로 지속 가능한 프로세스가 아니다.

> ..따라서 우선 해야 할 일은 변경의 범위를 제한하는 것이다.

> ..다음으로 해야 할 일은 테스트와 리팩토링 사이에 존재하는 교착상태를 풀어주는 것이다.

> ..테스트가 아닌 다른 방법으로도 피드백을 얻을 수 있는데, 아주 조심스럽게 작업하는 방법이나 파트너와 함께 작업을 하는 방법 등이 그런 것들이다. ..이 피드백을 이용해 우리가 바꾸어야 하는 부분이 변화에 좀 더 수용적이게 되도록 할 수 있다.

> ..시간이 지나면서, 시스템에서 늘 변화하는 부분들은 테스트 주도로 된 것처럼 보이게 될 것이다.



### TDD 는 누구를 위한 것인가?

> ..만약 당신이 어느 정도는 작동하는 코드를 왕창 입력해 넣는 것에 행복해 하고, 그 결과를 두 번 다시 쳐다보지 않는 것에 행복해 한다면, TDD 는 당신을 위한 것이 아니다. **TDD 는 더 나은 코드를 작성한다면 좀 더 성공할 것이라는 ..해커적인 가정에 근거한다.**

> ..TDD 는 코드에 감정적 애착을 형성하는 해커들에게도 좋다.

> ..**TDD 는 시간이 지남에 따라 코드에 대한 자신감을 점점 더 쌓아갈 수 있게 해준다.** 테스트가 쌓여감에 따라 (그리고 여러분의 테스팅 기술이 늘어감에 따라) 시스템의 행위에 대한 자신감을 더 많이 얻게 된다. 설계를 개선해 나감에 따라 시스템의 행위에 대한 자신감을 더 많이 얻게 된다. 설계를 개선해 나감에 따라 점점 더 많은 설계 변경이 가능해진다.

> ..나의 목적은 처음 반짝이는 눈빛으로 프로젝트를 시작할 때보다 **프로젝트를 시작하고 1년이 지난 후에 더 좋은 느낌을 갖게 되는 것인데, TDD 가 이 목적을 달성할 수 있도록 도와준다.**



### TDD 는 초기 조건에 민감한가?

> ..만약 TDD 가 작은 차원에서 초기 조건에 민감하다면, 큰 차원에서는 예측 가능할까? (미시시피강의 작은 소용돌이들은 예측 불가능 하지만, 강 어귀에서 대략 초당 2,000,000 세제곱 피트 정도의 물이 흐른다는 것은 믿을 수 있다)



### TDD 와 패턴의 관계는?

> ..내가 알아챈, 그리고 다른 이들도 알아채길 바라는 것은, **반복적 행동을 규칙으로 환원함으로써 규칙을 적용하는 것은 기계적이며 단순 암기가 된다는 점이다. 이것은 언제나 최초 원리에서 시작해서 모든것을 다시 논구하는 것보다 더 빠르다. 예외 혹은 규칙의 어느 것도 들어맞지 않는 문제가 있을 경우, 새로운 것을 창조하고 적용할 더 많은 시간과 에너지를 갖게 된다.**

> ..TDD 와 패턴의 또 다른 관계는 패턴 주도 설계(pattern-driven design) 에 대한 구현 방법으로써의 TDD 다.

> ..문제는 설계가 항상 우리를 놀라게 만든다는 점이다. 완벽하게 사리에 맞는 설계 아이디어가 결국은 틀린 것으로 판명난다. 그냥 시스템이 무슨 일을 할지 생각하고 나중에 설계가 알아서 정해지도록 하는 것이 더 낫다.



### 어쨰서 TDD 가 잘 작동하는가?

> ..TDD 가 장애율 낮고 유지보수 비용이 적으며, 결합력이 낮고 응집력이 강한 시스템을 높은 생산성으로 만들어낼 수 있게 해준다고 잠시 동안만 가정해보자. 어떻게 이런 일이 가능할까?

> ..이 결과의 일부는 분명 결함 감소에서 온다. 결함을 빨리 발견해 고칠수록 비용은 낮아진다. 가끔은 엄청나게 낮아지기도 한다.

> ..결함 감소에서 오는 이차적인 심리학적, 사회적 효과가 무척 많다. 나는 TDD 를 시작한 이후로 스트레스를 훨씬 적게 받게 됐다. 모든 것에 대해 한꺼번에 걱정할 필요가 없게 됐다. 나는 직면한 테스트 하나를 실행하게 할 수 있고, 그 뒤엔 나머지를 전부 실행할 수도 있다.

> ..TDD 의 또 다른 효과는 설계 결정에 대한 피드백 고리를 단축시킨다는 점이다.

> ..설계 결정에 대한 피드백 루프의 길이는 설계에 대한 생각 (API 가 이런식으로 생기면 좋겠다, 혹은 메타포가 이래야 할 것이다 등) 과 그에 대한 첫 번째 예제 (그 생각을 담고 있는 테스트 작성) 사이의 간격이다. 

> ..**설계에 대한 결정을 내리고 기쁨이나 고통을 맛보기까지 몇 주에서 몇 달을 기다리는 대신, 설계 아이디어를 몇 초에서 몇 분 사이에 그럴듯한 인터페이스로 전환하기만 하면 피드백을 받울 수 있게 된 것이다.**

> .."올바른 코드를 절대치가 아니라 극한 함수로써 '끌어들이는' 프로그래밍 실행법을 도입하라. **모든 기능에 대해 단위 테스트를 작성한다면, 각 단계 사이에서 코드 단순화를 위해 리팩토링한다면, 한 번에 하나씩 기능을 추가하고 모든 단위테스트가 통과한 후에만 추가한다면,** 당신은 수학자들이 '끌개(attactor)' 라고 부르는 것을 만들어 내게 될 것이다. 이 끌개라는 것은 모든 흐름이 그곳으로 수렴하는 상태 공간의 점이다. 이것은 코드가 시간이 지남에 따라 더 나빠지기보다 더 좋아지도록 하는 경향이 있다"



### 이름을 테스트 주도 개발 이라고 한 이유는?

> 개발 : 의사결정에 시차가 있으면 그 사이에 피드백이 어렵기 떄문에, 소프트웨어 개발을 어떤 단계(phase) 에 따라 나누는 과거의 사고 방식은 약화되었다. 여기에서 "개발(development)" 이란 분석, 논리적설계, 물리적설계, 구현, 테스팅, 검토, 통합, 배포를 아우르는 복잡한 춤을 말한다.

> 주도 : 어떤 이름의 반대는 최소한 모호하게라도 불만족스러워야 한다는 명명 법칙이 있다. (구조적 프로그래밍의 매력 가운데 하나는 아무도 비구조적인 걸 원하지 않는다는 것이다) 만약 개발을 테스트로 주도하지 않는다면, 무엇으로 주도할 것인가? 추측(speculation)으로? 명세(specification)로?

> 테스트 : 자동화되고 구체적이며 명확한 테스트를 말한다. 



### TDD 와 익스트림 프로그래밍의 실천법 사이에 어떤 관련이 있는가?

> 짝 프로그래밍 : **TDD 를 하면서 작성하게 되는 테스트는 짝 프로그래밍 과정에서 뛰어난 의사소통 수단이 된다.** ..짝으로 일하는 것은 TDD 를 강화하는데, 당신이 지칠 때 머릿속에 활기를 되찾게 해주기 때문이다.

> 활기차게 일하기 : XP 에서는 기운이 있을 때 일을 시작해서 지치면 그만할 것을 권유한다. 다음 테스트를 통과시키지 못하겠거나, 어떤 테스트 두 개를 동시에 통과하도록 만들 방법을 모르겠다면, 잠시 쉴 시간이다.

> 지속적인 통합 : 테스트는 좀더 자주 통합할 수 있게 해주기 때문에 아주 훌륭한 자원이 된다. 새로운 테스트를 통과시킨 후 중복을 제거했다면 체크인한다. ..이 방법이야말로 많은 프로그래머들로 구성된 큰 팀에서 동일한 코드베이스를 사용할 수 있게 하는 핵심 중 하나다. .."n 이 항상 1 이라면 n^2 문제는 더 이상 문제가 아니다"

> 단순 설계 : **테스트를 통과하기 위해 필요한 만큼만 코딩하고 모든 중복을 제거한다면,** 여러분은 자동으로 현재까지의 요구사항에 딱 들어맞는 설계를 얻게 될 것이고, 이 설계는 앞으로의 어떠한 사용자 스토리(user story) 에 대해서도 동등하게 준비된 상태일 것이다.

> 리팩토링 : **테스트가 있다면 더 큰 리팩토링을 수행하더라도 시스템의 행위가 변하지 않았다는 자신감을 얻을 수 있게 될 것이고,** 결과적으로 시스템의 수명은 더 길어질 것이다. 리팩토링을 통해 다음 단계의 테스트를 더 쉽게 작성할 수 있을 것이다.

> 지속적인 전달 : **TDD 테스트들이 정말 당신 시스템의 MTBF 를 개선한다면,** 고객을 혼란시키지 않으면서도 훨씬 더 자주 코드를 출시할 수 있을 것이다.


