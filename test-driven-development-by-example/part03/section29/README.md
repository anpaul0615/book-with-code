# 29장 xUnit 패턴
 

## 메모

> 다음은 xUnit 계열 테스팅 프레임워크를 위한 패턴이다.



### 단언 (assertion)

> 테스트가 잘 작동하는지 어떻게 검사할 것인가?  
> 불리언(boolean) 수식을 작성해서 여러분 대신 프로그램이 자동으로 코드가 동작하는지에 대한 판단을 수행하도록 하라.

> ..**테스트를 완전히 자동화하려먼 결과를 평가하는데 개입되는 인간의 판단을 모조리 끄집어내야 한다. ..이것은 다음 사항을 의미한다.**  
> 1) 판단 결과가 불리언 값이어야 한다. 일반적으로 참 값은 모든 테스트가 통과했음을 의미하고, 거짓 값은 뭔가 예상치 못했던 일이 발생했음을 의미한다.  
> 2) 이 불리언 값은 컴퓨터에 의해 검증되어야 한다. 보통 다양한 형태의 assert 메서드를 호출하여 이 값을 얻어낸다.  

> ..**단언은 구체적이어야 한다. 만약 면적이 50 이어야 한다면, 다음과 같이 면적이 50 이어야 한다고 적어주어야 한다.**  
> `assertTrue(rectangle.area() == 50)`

> ..그러나 화이트박스 테스트를 바라는 것은 테스팅 문제가 아니라 설계 문제다. 코드가 제대로 작동하는지를 판단하기 위한 용도로 변수를 사용하길 원한다면, 언제나 설계를 향상할 수 있는 기회가 있다. 하지만 두려움 때문에 포기하고 그냥 변수를 사용하기로 결정해 버리면 이 기회를 잃게 된다.



### 픽스처

> 여러 테스트에서 공통으로 사용하는 객체들을 생성할 때 어떻게 하면 좋을까?  
> 각 테스트코드에 있는 지역 변수를 인스턴스 변수로 바꾸고 setUp() 메서드를 제정의하여 이 메서드에서 인스턴스 변수들을 초기화하도록 한다. 

> ..문제는 이렇다. 여러분은 종종 객체들을 원하는 상태로 세팅하는 코드를 작성하고 나서, 이 객체들을 조작하고 결과를 테스트하나는 코드를 만든다. 그런데 객체들을 세팅하는 코드는 여러 테스트에 걸쳐 동일한 경우가 있다. (이러한 객체들을 테스트 픽스처(fixture) 혹은 발판(scaffolding) 이라고 부른다)

> ..이와 같은 중복은 다음과 같은 이유로 좋지 않다.  
> 1) 복사해서 붙이기를 한다고 하더라도 이런 코드를 반복 작성하는 것엔 시간이 소요되는데, 우리는 테스트를 빨리 작성하길 원한다.  
> 2) 인터페이스를수동으로 변경할 필요가 있을 경우, 여러 테스트를 고쳐주어야 한다. (이는 중복에 대해 정확히 예상되는 결과다)

> ..하지만 위에서 말한 중복에 좋은 점도 존재한다. 객체 세팅 코드들이 단언이 적힌 메서드에 포함되면 우리는 테스트코드를 그냥 위에서 아래로 읽어내려 갈 수 있다.

> ..하지만 객체 세팅 코드들이 별도의 메서드(setUp) 으로 분리되면 우리는 테스트의 나머지 부분을 작성하기 전에 그 메서드가 자동으로 호출된다는 점과 객체들이 어떻게 초기화되었는지를 기억해야 한다.

> ..TestCase 의 하위클래스와 하위클래스 인스턴스 사이의 관계는 xUnit 에서 가장 혼란스러운 부분 중 하나이다. 새로운 종류의 픽스처는 각각 TestCase 의 새로운 하위클래스여야 한다. 이 하위클래스의 인스턴스 안에서 새로운 픽스처가 각각 생성되어 한 번 사용된 후 버려진다.

> ..이 말은, 테스트클래스와 모델클래스 사이에 어떠한 단순한 관계가 존재하지 않는다는 걸 의미한다.

> ..**한 픽스처가 여러 클래스를 테스트하는데 쓰이는 경우도 있고(물론 이런경우는 흔치 않다), 한 모델 클래스를 테스트하는 데 두 세 개의 픽스처가 필요한 경우도 있다.** 실제 업무에서 테스트 클래스와 모델 클래스의 수가 대충 비슷하게 유지되지만, 한 모델 클래스에 대해서 한 테스트 클래스가 대응되기 때문은 아니다.



### 외부 픽스처

> 픽스처 중 외부 자원이 있을 경우 이를 어떻게 해제할 것인가?  
> tearDown 메서드를 재정의하여 이곳에서 자원을 해제하면 된다.

> ..**각 테스트의 목적 중 하나는 테스트가 실행되기 전과 실행된 후의 외부 세계가 동일하게 유지되도록 만드는 것임을 기억하기 바란다.** 예를 들어 테스트 중에 파일을 열었다면 테스트가 끝나기전에 이를 반드시 닫아야 한다.

> ..xUnit 은 각각의 테스트가 끝난 후에 tearDown 이 호출되는 것을 보장해준다. tearDown 은 테스트 메서드에서 무슨 일이 벌어졌건 간에 상관 없이 호출될 것이다.



### 테스트 메서드

> 테스트 케이스 하나를 어떻게 표현할 것인가?  
> "test" 로 시작하는 이름의 메서드로 나타내면 된다.

> ..만약 픽스처를 표현하기 위해 클래스를 사용하기로 결정한다면 각각의 테스트를 위한 장소는 자연스럽게 메서드로 결정된다. **동일한 픽스처를 공유하는 모든 테스트는 동일한 클래스의 메서드로 작성될 것이다. 다른 종류의 픽스처를 필요로 하는 테스트는 다른 클래스에 존재하게 된다.**

> ..관습에 의해 메서드 이름은 "test" 로 시작한다. 툴은 이 패턴을 자동으로 인식하고 주어진 클래스에 대한 테스트슈트를 생성한다.

> ..**메서드 이름의 나머지 부분은 나중에 아무것도 모르는 사람이 이 코드를 읽더라도 왜 이 테스트가 작성되었는지를 알 수 있도록 단서를 주어야 한다.**

> ..예를 들어 JUnit 에는 "testAssertPosInfinityNotEqualsNegInfinity" 라는 테스트가 있다. 테스트 작성 당시에 대해 기억이 나지는 않지만 이름으로 미루어 보건대 과거 어느 순간에 JUnit 의 부동소수점 관련 단언 코드에서 양의 무한대와 음의 무한대를 구분하지 못한 적이 있는 모양이다.

> ..테스트 메서드는 의미가 그대로 드러나는 코드로, 읽기 쉬워야 한다. 테스트코드가 점점 길어지고 복잡해진다면, 아기걸음 게임을 할 필요가 있다. 이 게임의 목적은 최종 목표에 좀더 다가갈 수 있게 해주는 가장 짧은 테스트를 작성하는 것이다. 일부러 코드를 꼬는 일이 없다면, 대략 세 줄 정도가 될 것이다. **컴퓨터나 나 자신을 위해서가 아니라, 후에 코드를 읽게 될 다른 사람을 위해 테스트를 작성한다는 사실을 기억하기 바란다.**

> ..테스트를 작성하기 전에 일단 원하는 테스트에 대한 짧은 아웃라인을 적는다. 예를들어,  
> ```
> /* 튜플 공간(tuple space)에 추가하기 */
> /* 튜플 공간에서 갖고오기 */
> /* 튜플 공간에서 읽어들이기 */
> ```

> ..이것들은 내가 각 카테고리 밑에 특정 테스트를 추가할 때까지 일종의 임시 자리표시(place holders) 가 된다. 내가 테스트를 추가할 때, 아웃라인에 또 다른 레벨의 코멘트를 추가한다.  
> ```
> /* 튜플 공간(tuple space)에 추가하기 */
> /* 튜플 공간에서 갖고오기 */
> /* 존재하지 않는 튜플 가져오기 */
> /* 존재하는 튜플 가져오기 */
> /* 복수 개의 튜플 가져오기 */
> /* 튜플 공간에서 읽어들이기 */
> ```

> ..나는 아웃라인에 보통 두 세 개의 레벨만 넣는다. 그것보다 더 많이 단 경우는 생각나지 않는다. **하지만 아웃라인은 본질적으로 테스트하는 클래스의 계약 문서가 되는 것이다.** ..아웃라인에서 가장 낮은 레벨 바로 밑에는 테스트케이스 코드가 오게 된다.



### 예외 테스트

> 예외가 발생하는 것이 정상인 경우에 대한 테스트는 어떻게 작성할 것인가?  
> **예상되는 예외를 잡아서 무시하고, 예외가 발생하지 않은 경우에 한해서 테스트가 실패하게 만들면 된다.**

> ..어떤 값을 찾는 테스트를 작성한다고 치자. 값이 찾아지지 않으면 예외가 던져지길 원한다.  
> ```
>	public void testRate() {
>		exchange.addRate("USD", "GBP", 2);
>		int rate = exchange.findRate("USD", "GBP");
>		assertEquals(2, rate);
>	}
> ```

> ..하지만 예외가 제대로 발생하는지에 대해 테스트할 방법이 쉽게 떠오르지 않는다. 다음과 같이 하면 된다.  
> ```
>	public void testMissingRate() {
>		try {
>			exchange.addRate("USD", "GBP", 2);
>			fail();
>		} catch (IllegalArgumentException expected) {
>		}
>	}
> ```

> ..findRate() 가 예외를 던지지 않는다면 fail() 이 호출될 것이다. fail() 은 테스트가 실패했음을 알려주기 위한 xUnit 메서드다.

> ..**우리가 원하는 정확한 종류의 예외만을 잡아내야 한다는 점에 유의하기 바란다. 그래야만 우리가 원하는 예외가 아닌, 다른 예외가 발생한 경우 테스트가 적절히 실패할 것이기 때문이다.**



### 전체 테스트

> 모든 테스트를 한번에 실행하려면 어떻게 해야 할까?  
> **모든 테스트슈트에 대한 모음**을 작성하면 된다. (각각의 패키지에 대해 하나씩, 그리고 전체 애플리케이션의 패키지 테스트를 모아주는 테스트슈트)

> ..대부분의 xUnit 구현과 IDE 에서 이 기능이 지원되지 않기 때문에, 각각의 패키지는 AllTests 라는 이름의 클래스를 가지고 있어야 한다. 이 클래스는 TestSuite 인스턴스를 반환하는 suite() 라는 이름의 정적 메서드를 가지고 있어야 한다.

> ..통화 예제에 대한 AllTests 는 다음과 같다.  
> ```
>	public class AllTests {
>		public static void main(String[] args) {
>			junit.swingui.TesetRunner.run(AllTests.class);
>		}
>		public static Test suite() {
>			TestSuite result = new TesetSuite("TFD tests");
>			result.addTestSuite(MoneyTest.class);
>			result.addTestSuite(ExchangeTest.class);
>			result.addTestSuite(IdentityRateTest.class);
>			return result;
>		}
>	}
> ```



